-- Handles the graphical part of the panel.
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local Theme = require(script.Parent.Theme)
local Shared = require(script.Parent.Shared)

local Panel = script.Parent.Parent
local SettingsContainer = Panel.Settings.ScrollingFrame
local DisplayFrame = Panel.MainFrame.ContentDisplay
local PlayerList = Panel.MainFrame.PlayerList
local PluginsList = Panel.MainFrame.Plugins.Container

local CTRL_Down = false -- Used for multi selection
local PlayersSelected = {}
local PluginsName = Shared.GetPluginsName() -- {PluginName = {Name = Name}}
local SectionDisplayed, CommandVisible = nil, nil

--[[
-- ChangePluginsShown(NewSection) accepts NewSection Frame argument and aims to facilitate the changing between
-- plugins functionality which was generated by the script.
--]]
local function ChangePluginShown(NewSection)
  if SectionDisplayed then SectionDisplayed.Visible = false end
  NewSection.Visible = true
  SectionDisplayed = NewSection
end

--[[
-- HandleBoolSetting(Name) accepts Name string as an argument and aims to centralize Bool related settings. Name **must** exist 
-- within SettingsContainer, else it will throw an error.
--]]
local function HandleBoolSetting(Name)
  if Panel:GetAttribute(Name) then
    SettingsContainer[Name].State.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
  else
    SettingsContainer[Name].State.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
  end

  Panel:SetAttribute(Name, not Panel:GetAttribute(Name))
end

--[[
-- RefreshPlayerList() can be called freely whenever the `PlayerList` ScrollingFrame has to be updated. Normally it's called
-- whenever a new player joins or a command is fired, after PlayersSelected table is cleared.
--]]
local function RefreshPlayerList()
  local Order = 0
  --[[
  -- CreatePlayerButton(Player) accepts a Player instance as argument and based on it and based on the provided settings it creates
  -- a new button or updates an existing button within PlayerList ScrollingFrame. Order variable has to be manually updated.
  --]]
  local function CreatePlayerButton(Player)
    local Template = PlayerList.Container:FindFirstChild(Player.Name)

    if not Template then
      -- If there isn't any existing button, simply create a new one with the template found within PlayerList and update its elements.
      Template = PlayerList.Container.Template:Clone()
      Template.ImageLabel.Image = game:GetService("Players"):GetUserThumbnailAsync(Player.UserId,
      Enum.ThumbnailType.HeadShot,
      Enum.ThumbnailSize.Size60x60)

      Player.Destroying:Connect(function()
        Template:Destroy()
      end)

      Template.Interact.MouseButton1Up:Connect(function()
        -- Holding down CTRL allows you to select multiple players at once. This aims to allow you do so.
        if CTRL_Down then
          if not table.find(PlayersSelected, Player) then
            table.insert(PlayersSelected, Player)
          else
            for i, v in pairs(PlayersSelected) do
              if v == Player then table.remove(PlayersSelected, i) end
            end
          end
        else
          PlayersSelected = {[1] = Player}
        end
      end)
    end

    Template.Parent = PlayerList.Container
    Template.Name = Player.Name
    Template.LayoutOrder = Order -- Order is modified outside the function.

    Template.Visible = true
  end

  -- Considering that there may be players which aren't in a team, they should appear on top of other teams.
  for _, Player in pairs(Players:GetPlayers()) do
    Order = Order + 1
    CreatePlayerButton(Player)
  end

  -- In the end, update the PlayerList CanvasSize based on information given by the UIListLayout
  PlayerList.CanvasSize = UDim2.new(0, PlayerList.Container.UIListLayout.AbsoluteContentSize.X,
  0, PlayerList.Container.UIListLayout.AbsoluteContentSize.Y)
end

--[[
-- HandleVisibilityAnimation(Frame, In) accepts Frame instance and In bool arguments, and based on them play the popup / close
-- animation, whose properties are defined in Theme module. The function yields until animation is finished. In argument
-- is true when Scaling should go to 0 and false when scaling should go to 1.
--]]
local function HandleVisibilityAnimation(Frame, In)
  local Tween

  if In then
    Tween = TweenService:Create(Frame.UIScale, Theme.WindowClose, {Scale = 0})
  else
    Tween = TweenService:Create(Frame.UIScale, Theme.WindowPopup, {Scale = 1})
  end

  Tween:Play()
  if not In then Frame.Visible = true end
  Tween.Completed:Wait()
  if In then Frame.Visible = false end
end

Panel.PanelButton.MouseButton1Up:Connect(function()
  HandleVisibilityAnimation(Panel.MainFrame, Panel.MainFrame.Visible)
  -- if Panel.Terminal.Visible then HandleVisibilityAnimation(Panel.Terminal, true) end
end)

Players.PlayerAdded:Connect(function()
  RefreshPlayerList()
end)

UIS.InputBegan:Connect(function(Input, Processed)
  if Input.KeyCode == Enum.KeyCode.Equals and not Processed then
    HandleVisibilityAnimation(Panel.MainFrame, Panel.MainFrame.Visible)
    if Panel.Terminal.Visible then HandleVisibilityAnimation(Panel.Terminal, true) end
  elseif Input.KeyCode == Enum.KeyCode.LeftControl and not Processed then
    CTRL_Down = true
  end
end)

UIS.InputEnded:Connect(function(Input)
  if Input.KeyCode == Enum.KeyCode.LeftControl then
    CTRL_Down = false
  end
end)

-- This loop here wastes resources and the functionality should be reimplemented -@SuperPuiu
game:GetService("RunService").Stepped:Connect(function()
  for _, v in pairs(Panel.MainFrame.PlayerList.Container:GetChildren()) do
    if not v:IsA("Frame") or v.Name == "Template" then continue end

    if not table.find(PlayersSelected, Players:FindFirstChild(v.Name)) then
      v.BackgroundTransparency = 1
    else
      v.BackgroundTransparency = 0.8
    end
  end
end)

SettingsContainer.OutputOnExecution.State.MouseButton1Up:Connect(function()
  HandleBoolSetting("OutputOnExecution")
end)

SettingsContainer.TerminalVisibility.State.MouseButton1Up:Connect(function()
  HandleBoolSetting("TerminalVisibility")
  HandleVisibilityAnimation(Panel.Terminal, not Panel:GetAttribute("TerminalVisibility"))
end)

SettingsContainer.ResizingEnabled.State.MouseButton1Up:Connect(function()
  HandleBoolSetting("ResizingEnabled")
end)

SettingsContainer.PlayerButtonNaming.State.MouseButton1Up:Connect(function()
  SettingsContainer.PlayerButtonNaming.ScrollingFrame.Visible = true
end)

DisplayFrame.Arguments.Execute.Interact.MouseButton1Up:Connect(function()
  local ArgumentsTable = {}
  
  for _, Argument in pairs(DisplayFrame.Arguments:GetChildren()) do
    if not Argument:IsA("Frame") then continue end
    if Argument.Name == "InputField" or Argument.Name == "Execute" or Argument.Name == "BoolField" then continue end

    if Argument:GetAttribute("DataType") == "string" then
      ArgumentsTable[Argument.Name] = Argument.TextBox.Text
    elseif Argument:GetAttribute("DataType") == "bool" then
      ArgumentsTable[Argument.Name] = Argument.TextButton:GetAttribute("Status")
    elseif Argument:GetAttribute("DataType") == "number" then
      ArgumentsTable[Argument.Name] = tonumber(Argument.TextBox.Text)
    end
  end

  Shared.RunCommand(CommandVisible, PlayersSelected, ArgumentsTable)
  PlayersSelected = {}
  RefreshPlayerList()
end)

for Name, PluginTable in pairs(PluginsName) do
  if Name == "LocalCommands" then continue end
  if Panel.MainFrame.Plugins.Container:FindFirstChild(Name) then
    warn(string.format("[PANEL]: Category %s already exists. Continuing with other plugins.", Name))
    continue
  end
  
  local DisplayButton = PluginsList.Settings:Clone()
  DisplayButton.Parent = PluginsList
  DisplayButton.TextLabel.Text = PluginTable.Name
  DisplayButton.Name = Name

  local ButtonList = DisplayFrame.Buttons.Template:Clone()
  ButtonList.Name = Name
  ButtonList.Parent = DisplayFrame.Buttons
  
  for P_Name, Plugin in pairs(PluginTable) do
    -- Ignore plugin metadata
    if P_Name == "Name" or P_Name == "Descriptions" or P_Name == "RequireExArguments" then continue end
    -- Create the button
    local PluginButton = ButtonList.TextButton:Clone()
    PluginButton.Name = Plugin
    PluginButton.Text = Plugin
    PluginButton.Parent = ButtonList
    PluginButton.Visible = true

    PluginButton.MouseButton1Up:Connect(function()
      for _, v in pairs(DisplayFrame.Arguments:GetChildren()) do
        if v.Name ~= "Execute" and v:IsA("Frame") and v.Name ~= "InputField" and v.Name ~= "BoolField" then v:Destroy() end
      end
      
      if PluginTable.RequireExArguments[Plugin] then
        for FieldName, RequiredData in pairs(PluginTable.RequireExArguments[Plugin]) do
          local FieldTemplate

          if RequiredData == "string" or RequiredData == "number" then
            FieldTemplate = DisplayFrame.Arguments.InputField:Clone()
          elseif RequiredData == "bool" then
            FieldTemplate = DisplayFrame.Arguments.BoolField:Clone()
            
            FieldTemplate.TextButton.MouseButton1Up:Connect(function()
              FieldTemplate.TextButton:SetAttribute("Status", not FieldTemplate.TextButton:GetAttribute("Status"))

              if FieldTemplate.TextButton:GetAttribute("Status") == true then
                FieldTemplate.TextButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
              else
                FieldTemplate.TextButton.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
              end
            end)
          end
          
          FieldTemplate:SetAttribute("DataType", RequiredData)
          FieldTemplate.Parent = DisplayFrame.Arguments
          FieldTemplate.TextLabel.Text = FieldName
          FieldTemplate.Name = FieldName
          FieldTemplate.Visible = true
        end
      end
      
      CommandVisible = Plugin
      DisplayFrame.Arguments.Execute.Visible = true
      
      DisplayFrame.Arguments.CanvasSize = UDim2.fromOffset(0, DisplayFrame.Arguments.UIListLayout.AbsoluteContentSize.Y)
    end)
  end
end

for _, Button in pairs(Panel.MainFrame.Plugins.Container:GetChildren()) do
  if not Button:IsA("TextButton") then continue end

  Button.MouseButton1Up:Connect(function()
    --[[Shared.RunCommand(Button.Name, PlayersSelected)
    PlayersSelected = {}
    RefreshPlayerList()]]
    ChangePluginShown(DisplayFrame.Buttons[Button.Name])
    game:GetService("RunService").RenderStepped:Wait()
    DisplayFrame.Buttons.CanvasSize = UDim2.fromOffset(0, DisplayFrame.Buttons[Button.Name].UIListLayout.AbsoluteContentSize.Y)
  end)
end

if Panel:GetAttribute("AlwaysOnTop") then Shared.SetHighestDisplayOrder() end
Panel:SetAttribute("ResizingEnabled", true)
Panel:SetAttribute("OutputOnExecution", true)

PluginsList.Parent.CanvasSize = UDim2.new(UDim2.fromOffset(0, PluginsList.UIListLayout.AbsoluteContentSize.Y))
RefreshPlayerList()
